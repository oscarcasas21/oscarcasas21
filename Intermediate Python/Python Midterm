{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## MIDTERM - W200 Introduction to Data Science Programming, UC Berkeley MIDS"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Instructions\n",
    "The midterm exam is designed to evaluate your grasp of Python theory as well as Python coding.\n",
    "\n",
    "- This is an individual open book exam.\n",
    "- You have 48 hours to complete the exam and upload it back to ISVC, starting from the point when you first accessed it on ISVC.\n",
    "- You may use any libraries from the Python Standard Library for this exam: https://docs.python.org/3/library/\n",
    "\n",
    "For the coding questions, follow best practices.  Partial credit may be given for submissions that are clearly commented and well organized."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 1. Short Questions (15 pts)\n",
    "\n",
    "1.1. Python's dynamic typing allows one variable to refer to multiple types of objects within the same program execution.  This can speed program development.  Name one disadvantage of dynamic typing."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "a)There tends to be more errros at runtime."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1.2. Compiled languages typically offer faster performance than interpreted languages. List two reasons why would you choose an interpreted language like Python for the purpose of analyzing a data set instead of a compiled language."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "a) Interpreted language tend to have smaller program sizes than the compiler counterparts.\n",
    "b) Interpreted language is also platform independent."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1.3. We have gone over FOR and WHILE loops.  Discuss one reason to use a for loop over a while loop and one reason to use a while loop over a for loop. Please elaborate beyond a single word."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "a)We should use a for loop over a while loop when we know the amount of times the loop needs to be run.\n",
    "b)We should use a while loop over a for loop when we want to loop until a certain condition is met."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 2. Programming Styles (10 pts)\n",
    "\n",
    "We have taught you a number of ways to program in Python. These have included using scripts versus functions and using Jupyter notebooks versus calling .py files from the command line. Describe a scenario in which you would use .py files from the command line over a Jupyter notebook and the opposite. Describe a scenario in which you would use a script versus a function and the opposite.  There are four cases and each answer should be about 1-2 sentences, explain why!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2.1. I would use a Jupyter notebook:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When sharing live code to my peers. It will also be better for result visualization."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2.2. I would use .py files over a Jupyter notebook:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When creating specific modules that will be used later in other programs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2.3. I would use a script over a function:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When the block of code only has to be used once in the the program."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2.4. I would use a function over a script:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When the block of code in question has to be used in many different areas of the whole file or when that block of code might be called by other scripts through the import module."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 3. Dictionaries vs Lists (10 pts)\n",
    "\n",
    "Suppose we have the following problem.  We have a dictionary of names and ages and we would like to find the oldest person.\n",
    "\n",
    "```\n",
    "ages_dict = {'Bill':34, 'Fred':45, 'Alice':14, 'Betty':17}\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Dictionary approach\n",
    "Here is a loop that shows how to iterate through the dictionary:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fred is the oldest.\n",
      "Time:  0.0009540480000396201\n"
     ]
    }
   ],
   "source": [
    "import timeit\n",
    "\n",
    "start = timeit.default_timer()\n",
    "\n",
    "ages_dict = {'Bill':34, 'Fred':45, 'Alice':14, 'Betty':17}\n",
    "\n",
    "max_age = 0\n",
    "max_name = ''\n",
    "for name,age in ages_dict.items():\n",
    "    if age > max_age:\n",
    "        max_age = age\n",
    "        max_name = name\n",
    "        \n",
    "print(max_name, \"is the oldest.\")    \n",
    "\n",
    "stop = timeit.default_timer()\n",
    "\n",
    "print('Time: ', stop - start)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### List approach \n",
    "\n",
    "Your friend comes to you and thinks that this dictionary is difficult to deal with and instead offers a different plan using two lists.\n",
    "\n",
    "```\n",
    "names = ['Bill', 'Fred', 'Alice', 'Betty']\n",
    "ages = [34, 45, 14, 17]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Instead of using a loop, your friend writes this code to find the oldest person."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Fred is the oldest.\n",
      "Time:  0.0006991039999775239\n"
     ]
    }
   ],
   "source": [
    "import timeit\n",
    "\n",
    "start = timeit.default_timer()\n",
    "names = ['Bill', 'Fred', 'Alice', 'Betty']\n",
    "ages = [34, 45, 14, 17]\n",
    "\n",
    "max_age = max(ages)\n",
    "index_max = ages.index(max_age)\n",
    "max_name = names[index_max]\n",
    "\n",
    "print(max_name, 'is the oldest.')\n",
    "\n",
    "stop = timeit.default_timer()\n",
    "\n",
    "print('Time: ', stop - start)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Discussion\n",
    "Discuss the advantages and disadvantages of each of the approaches.  \n",
    "\n",
    "3.1. Is one more efficient (i.e. faster in Big O notation) than the other?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "They are both equally efficient. This List is faster regarding execution time, however both looping and using the Max function have a Big O notation of O(n). The reason being is that the loop will iterate through each item to see if it greater than or equal to the current max value, but the max value also has to iterate through each item to find the max. The reason max is faster just has to do with the fact that built in fucntions are faster than new functions because of the way they are interpreted. However this is just the case for this specific script."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.2. Why would you prefer the dictionary?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I would prefer a dictionary if in my code I actively have to search for key value pairs. It is much faster to lookup \"Freds\" time than it is to find a value in a list. This is due to hashtables."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.3. Why would you prefer the two lists?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you need to have duplicate \"keys\" since the dictionary will just write over the last entry. So if for example you are inputting everyones lap times of 5 laps you might prefer a list so that you can input names multiple times."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 4. Mutability Surprises (15 pts)\n",
    "\n",
    "4.1. In the asynchronous sessions, we discussed mutability. Please describe, in your own words, why mutability is a useful feature in Python lists and dictionaries."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Mutability is important because it allows us to instead of creating new objects everytime we need to change an object we can just change specific values of that object or change the size, etc."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Mutability can also lead to unexpected behavior - specifically when multiple variables point to the same object or when mutable objects are nested inside each other. \n",
    "\n",
    "4.2. Please write some code demonstrating a situation where mutability could lead to unexpected behavior. Specifically, show how updating just one object (list_a) can change the value when you print a second variable (list_b)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "List A is [1, 0, 0, 0]\n",
      "List B is [1, 0, 0, 0]\n",
      "list_b was also changed when list_a was changed\n"
     ]
    }
   ],
   "source": [
    "#create first list\n",
    "list_a=[0,0,0,0]\n",
    "#make list b equal to a\n",
    "list_b=list_a\n",
    "#change first value in a\n",
    "list_a[0]=1\n",
    "\n",
    "print(f\"List A is {list_a}\")\n",
    "print(f\"List B is {list_b}\")\n",
    "print(\"List B was also changed when List A was changed\" )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4.3. Show how \"copy\" or \"deepcopy\" could be used to prevent the unexpected problem you described, above."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 191,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "List A is [1, 0, 0, 0]\n",
      "List B is [0, 0, 0, 0]\n",
      "List B was unchanged when List A was changed\n"
     ]
    }
   ],
   "source": [
    "#import necessary modules\n",
    "import copy\n",
    "\n",
    "#create first list\n",
    "list_a=[0,0,0,0]\n",
    "#Use deepcopy from copy module\n",
    "list_b=copy.deepcopy(list_a)\n",
    "#change first value in a\n",
    "list_a[0]=1\n",
    "\n",
    "print(f\"List A is {list_a}\")\n",
    "print(f\"List B is {list_b}\")\n",
    "print(\"List B was unchanged when List A was changed\" )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4.4. Now, show the same problem using two dictionaries. Again show how \"copy\" or \"deepcopy\" can fix the issue."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 192,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dict A is {'a': 1, 'b': 0}\n",
      "Dict B is {'a': 1, 'b': 0}\n",
      "Dict B changed as a result of Dict A\n",
      "\n",
      "Dict A is {'a': 1, 'b': 0}\n",
      "Dict A is {'a': 0, 'b': 0}\n",
      "Dict B unchanged from Dict A\n"
     ]
    }
   ],
   "source": [
    "#import necessary modules\n",
    "import copy\n",
    "\n",
    "#create first dict\n",
    "dict_a={\"a\":0,\"b\":0}\n",
    "#set equal to one another\n",
    "dict_b=dict_a\n",
    "#change first\n",
    "dict_a[\"a\"]=1\n",
    "\n",
    "print(f\"Dict A is {dict_a}\")\n",
    "print(f\"Dict B is {dict_b}\")\n",
    "print(\"Dict B changed as a result of Dict A\\n\")\n",
    "\n",
    "#Now try deepcopy\n",
    "dict_a={\"a\":0,\"b\":0}\n",
    "dict_b=copy.deepcopy(dict_a)\n",
    "dict_a[\"a\"]=1\n",
    "\n",
    "print(f\"Dict A is {dict_a}\")\n",
    "print(f\"Dict A is {dict_b}\")\n",
    "print(\"Dict B unchanged from Dict A\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4.5. Can this unexpected behavior problem occur with tuples? Why, or why not?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Tuples are immutable therefore they cannot change, this problem will not occur. If you try to change a tuple it will throw an error.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 5. Tweet Analysis (15 pts)\n",
    "\n",
    "A tweet is a string that is between 1 and 280 characters long (inclusive). A username is a string of letters and/or digits that is between 1 and 14 characters long (inclusive). A username is mentioned in a tweet by including @username in the tweet (notice the username does not include the `@` symbol). A retweet is way to share another user's tweet, and can be identified by the string RT, followed by the original username who tweeted it.\n",
    "\n",
    "Your job is to fill in the function *count_retweets_by_username* so that it **returns** a frequency dictionary that indicates how many times each retweeted username was retweeted."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 193,
   "metadata": {},
   "outputs": [],
   "source": [
    "tweets = [\"This is great! RT @fakeuser: Can you believe this?\",\n",
    "         \"It's the refs! RT @dubsfan: Boo the refs and stuff wargarbal\",\n",
    "         \"That's right RT @ladodgers: The dodgers are destined to win the west!\",\n",
    "         \"RT @sportball: That sporting event was not cool\",\n",
    "         \"This is just a tweet about things @person, how could you\",\n",
    "         \"RT @ladodgers: The season is looking great!\",\n",
    "         \"RT @dubsfan: I can't believe it!\",\n",
    "         \"I can't believe it either! RT @dubsfan: I can't believe it\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 196,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Import re which will help with string formatting since thr RT are between @ and :\n",
    "import re \n",
    "\n",
    "#define function and arguments\n",
    "def count_retweets_by_username(retweets):\n",
    "    \"\"\" (list of tweets) -> dict of {username: int}\n",
    "    Returns a dictionary in which each key is a username that was \n",
    "    retweeted in tweet_list and each value is the total number of times this \n",
    "    username was retweeted.\n",
    "    \"\"\"\n",
    "    # write code here and update return statement with your dictionary\n",
    "    #empty users to avoid append error\n",
    "    users = [] \n",
    "    for i in retweets:\n",
    "        #Search if RT in tweet no need to look if not, this avoids findall problem\n",
    "        if re.search(r'(?<=RT @)(.*?)(?=:)', i):\n",
    "            #now that we know RT in string find the username use findall\n",
    "            value = str(re.findall(r'(?<=RT @)(.*?)(?=:)', i)[0])\n",
    "            users.append(value)\n",
    "    #define new dict to avoid append error\n",
    "    dict_1 = {} \n",
    "    #loop through all RT usernames for count\n",
    "    for user in users:\n",
    "        if user in dict_1:\n",
    "            dict_1[user] = dict_1[user] + 1\n",
    "        else:\n",
    "            dict_1[user] = 1\n",
    "  \n",
    "    return dict_1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 197,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'fakeuser': 1, 'dubsfan': 3, 'ladodgers': 2, 'sportball': 1}\n"
     ]
    }
   ],
   "source": [
    "# allow this code to work by implementing count_retweets_by_username function above\n",
    "print(count_retweets_by_username(tweets))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 6. Looking for Minerals (20 pts)\n",
    "\n",
    "A mining company conducts a survey of an n-by-n square grid of land.  Each row of land is numbered from 0 to n-1 where 0 is the top and n-1 is the bottom, and each column is also numbered from 0 to n-1 where 0 is the left and n-1 is the right.  The company wishes to record which squares of this grid contain mineral deposits.\n",
    "\n",
    "The company decides to use a list of tuples to store the location of each deposit.  The first item in each tuple is the row of the deposit.  The second item is the column.  The third item is a non-negative number representing the size of the deposit, in tons.  For example, the following code defines a sample representation of a set of deposits in an 8-by-8 grid."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 198,
   "metadata": {},
   "outputs": [],
   "source": [
    "deposits = [(0, 4, .3), (6, 2, 3), (3, 7, 2.2), (5, 5, .5), (3, 5, .8), (7, 7, .3)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "6.1. Given a list of deposits like the one above, write a function to create a string representation for a rectangular sub-region of the land.  Your function should take a list of deposits, then a set of parameters denoting the top, bottom, left, and right edges of the sub-grid.  It should **return** (do not print in the function) a multi-line string in which grid squares without deposits are represented by \"-\" and grid squares with a deposit are represented by \"X\"."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 200,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "----X---\n",
      "--------\n",
      "--------\n",
      "-----X-X\n",
      "--------\n",
      "-----X--\n",
      "--X-----\n",
      "-------X\n",
      "\n",
      "X--\n",
      "---\n",
      "--X\n",
      "\n"
     ]
    }
   ],
   "source": [
    "def display(deposits, top, bottom, left, right):\n",
    "    \"\"\"display a subgrid of the land, with rows starting at top and up to \n",
    "    but not including bottom, and columns starting at left and up to but\n",
    "    not including right.\"\"\"\n",
    "    #Set number of horizontal matrices\n",
    "    horizontal = abs(left - right)\n",
    "    #Set number of vertical matrices\n",
    "    vertical = abs(top - bottom)\n",
    "    #Define list\n",
    "    matrix = []\n",
    "    \n",
    "    #iterate through row\n",
    "    for i in range(vertical):\n",
    "        inner_list = []\n",
    "        #iterate through columns\n",
    "        for j in range(horizontal):\n",
    "            #create row\n",
    "            inner_list.append(\"-\")\n",
    "        #append row to column\n",
    "        matrix.append(inner_list)\n",
    "\n",
    "    #iterate through each deposit\n",
    "    for i in deposits:\n",
    "        #check if deposit in area\n",
    "        if i[0] >= top and i[0] < bottom and i[1] >= left and i[1] < right:\n",
    "            matrix[i[0]-top][i[1]-left] = \"X\"\n",
    "            \n",
    "    #define empty string to add to itself\n",
    "    final_string = \"\"\n",
    "    #iterate through rows\n",
    "    for i in range(vertical):\n",
    "        #Join column values\n",
    "        string = ''.join(matrix[i]) \n",
    "        #add new line to past lines\n",
    "        final_string = final_string + string + \"\\n\"\n",
    "    #return print statement or else /n will not work   \n",
    "    return print(final_string)\n",
    "\n",
    "display(deposits,0,8,0,8)\n",
    "display(deposits,5,8,5,8)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For example, your function should replicate the following behavior for the example grid:\n",
    "```\n",
    "print(display(deposits, 0, 8, 0, 8))\n",
    "----X---\n",
    "--------\n",
    "--------\n",
    "-----X-X\n",
    "--------\n",
    "-----X--\n",
    "--X-----\n",
    "-------X\n",
    "\n",
    "print(display(deposits, 5, 8, 5, 8))\n",
    "X--\n",
    "---\n",
    "--X\n",
    "\n",
    "```\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "6.2. Next, complete the following function to compute the total number of tons in a rectangular sub-region of the grid."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 201,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "7.1\n",
      "0.8\n"
     ]
    }
   ],
   "source": [
    "def tons_inside(deposits, top, bottom, left, right):\n",
    "    \"\"\"Returns the total number of tons of deposits for which the row is at least top,\n",
    "    but strictly less than bottom, and the column is at least left, but strictly\n",
    "    less than right.\"\"\"\n",
    "    # Do not alter the function header.  \n",
    "    #Set number of horizontal matrices\n",
    "    horizontal = abs(left - right)\n",
    "    #Set number of vertical matrices\n",
    "    vertical = abs(top - bottom)\n",
    "    \n",
    "    #set sum to 0\n",
    "    sum = 0\n",
    "    #iterate through deposits\n",
    "    for i in deposits:\n",
    "        #make sure deposit is in the area\n",
    "        if i[0] >= top and i[0] < bottom and i[1] >= left and i[1] < right:\n",
    "            #add weigh to past sum\n",
    "            sum = sum + float(i[2])\n",
    "    #return sum of deposit\n",
    "    return print(sum)\n",
    "\n",
    "tons_inside(deposits,0,8,0,8)\n",
    "\n",
    "tons_inside(deposits,5,8,5,8)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "## 7. Birthday planning (15 pts)\n",
    "\n",
    "Suppose you record a list of birthdays for your classmates, recorded as month day tuples.  An example is given below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 202,
   "metadata": {},
   "outputs": [],
   "source": [
    "# The 2nd to last tuple needs the int(2) in it so that it is uniquely stored in memory compared to (2,8)\n",
    "# Under the hood Python 3.7 changed how these are stored so (2,8) and (2,8) are stored in the same location\n",
    "# and then the algorithm below doesn't work\n",
    "\n",
    "dates = [(3,14),(2,8),(10,25),(5,17),(3,2),(7,25),(4,30),(8,7),(int(2),8),(1,22)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You read about the famous birthday problem and you become interested in the number of pairs of classmates that share the same birthday.  Below is an algorithm you write to do this. (Note: the ```is``` operator tests that two operands point to the same object)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 203,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total birthday pairs: 1\n"
     ]
    }
   ],
   "source": [
    "count = 0\n",
    "\n",
    "for person_a in dates:\n",
    "    for person_b in dates:\n",
    "        # Make sure we have different people        \n",
    "        \n",
    "        if person_a is person_b:\n",
    "            continue\n",
    "            \n",
    "        # Check both month and day\n",
    "        if person_a[0] == person_b[0] and person_a[1] == person_b[1]:\n",
    "            count += 1\n",
    "            \n",
    "# We counted each pair twice (e.g. jane-bob and bob-jane) so divide by 2:\n",
    "print(\"Total birthday pairs:\", count//2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7.1. What is the (tightest) Big-O running time bound for the above algorithm?  You may assume that simple operations like equality check, addition, and print take constant time."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "It is O(n)^2 the reason being is that for each person it has to check every other person. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7.2. You notice that your algorithm is inefficient in that it counts each pair twice.  For example, it will increment count once when person_a is Jane and person_b is Bob, and again when person_a is Bob and person_b is Jane.  Below, revise the algorithm so that it only looks at each pair once."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 204,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total birthday pairs: 1\n"
     ]
    }
   ],
   "source": [
    "count = 0\n",
    "\n",
    "for i in range(len(dates)):\n",
    "    #This makes it so we never go back to people weve already checked\n",
    "    for j in range(i+1,len(dates)):\n",
    "        person_a = dates[i]\n",
    "        person_b = dates[j]\n",
    "        \n",
    "        # Make sure we have different people\n",
    "        if person_a is person_b:\n",
    "            continue\n",
    "                \n",
    "            # Check both month and day\n",
    "        if person_a[0] == person_b[0] and person_a[1] == person_b[1]:\n",
    "            count += 1\n",
    "\n",
    "#We counted each operson once\n",
    "print(\"Total birthday pairs:\", count)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7.3. What is the (tightest) Big-O running time bound for your new algorithm?  What does this tell you about whether your revision was worth making?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This running time is still O(n)^2 as we are still checking every other person that is right of the past loop."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7.4. Finally, create a third revision of your algorithm which has a faster Big-O running time bound that both the previous algorithms."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 206,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Total birthday pairs: 1\n"
     ]
    }
   ],
   "source": [
    "count = 0\n",
    "#sort dates \n",
    "dates.sort()\n",
    "\n",
    "#iterate through range of length of dates\n",
    "for i in range(len(dates)):\n",
    "    #new count in case more than 2 share bday\n",
    "    count_2 = 0 \n",
    "    # Check both month and day\n",
    "    while  i < (len(dates)-1) and dates[i][0] == dates[i+1][0] and dates[i][1]== dates[i+1][1]:\n",
    "        #add to count\n",
    "        count_2 = count_2 + 1\n",
    "        #i keeps increasing in while loop so when condition is met for loop starts right spot\n",
    "        i = i + 1\n",
    "    #sum of all counts\n",
    "    count = count + count_2\n",
    "\n",
    "    \n",
    "# We counted each pair once \n",
    "print(\"Total birthday pairs:\", count)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7.5. What is the (tightest) Big-O running time bound for your last algorithm?  Explain what trade-off you made to have a faster running time."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "The Big O running time of the fastest one is O(Nlog(N)) because since it is limited by the number of days and months in the year, the sorting will not increase in difficulty. It only checks one day at a time hence instead of checking each person to person it does by day of the year. One of the tradeoffs made was the fact that now if same value tuples are inputted by mistake, it will still count them unlike the other algorithms. Another more obvious tradeoff is that with low number N, the time complexity of sorting might take more time since it is sorting through a theoretical 365 inputs instead of the n number of people.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  },
  "widgets": {
   "state": {},
   "version": "1.1.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
